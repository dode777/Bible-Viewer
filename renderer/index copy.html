<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Bible Viewer</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0b0b; color:#eee; font-family: system-ui, AppleSDGothicNeo, "Segoe UI", Roboto, Arial; }
    header { padding:18px; font-weight:800; border-bottom:1px solid #222; }
    .wrap { padding:20px 18px; display:grid; gap:14px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    select, input[type="number"], input[type="checkbox"], button {
      padding:10px 12px; border-radius:10px; border:1px solid #333; background:#141414; color:#eee; outline:none; font-size:15px;
    }
    label { color:#aab; font-size:14px; margin-right:6px; }
    .hint { color:#96a0aa; font-size:13px; }
    button { cursor:pointer; }
    button:hover { background:#1c1c1c; }
    .sep { height:1px; background:#222; margin:6px 0; }
  </style>
</head>
<body>
  <header>Bible Viewer — 책/장/절 선택 & 모니터/폰트 옵션</header>
  <div class="wrap">
    <!-- 1) 책 먼저 -->
    <div class="row">
      <label>책</label>
      <select id="book"></select>
    </div>

    <!-- 2) 시작 장/절 -->
    <div class="row">
      <label>시작</label>
      <select id="sCh"></select>
      <label>장</label>
      <select id="sVs"></select>
      <label>절</label>
    </div>

    <!-- 3) 끝 장/절 + 같은 줄 체크박스 -->
    <div class="row">
      <label>끝</label>
      <select id="eCh"></select>
      <label>장</label>
      <select id="eVs"></select>
      <label>절</label>
      <label style="margin-left:8px;">
        <input type="checkbox" id="sameEnd" /> 끝 장/절을 시작과 동일
      </label>
    </div>

    <!-- 4) 모니터 + 폰트 + 버튼 -->
    <div class="row">
      <label>표시 모니터</label>
      <select id="display"></select>

      <label>폰트크기(px)</label>
      <input id="font" type="number" min="14" max="96" step="1" value="28" style="width:96px" />
      <button id="showBtn">구절 띄우기</button>
    </div>

    <div class="sep"></div>
    <div class="hint">• 책을 고르면 장/절 목록이 자동 갱신됩니다. • “끝 장/절 동일” 체크 시 끝값은 비활성화되고 시작값을 따라갑니다.</div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const $book = $('book'), $sCh = $('sCh'), $sVs = $('sVs'), $eCh = $('eCh'), $eVs = $('eVs');
    const $same = $('sameEnd'), $font = $('font'), $disp = $('display'), $btn = $('showBtn');

    let META = null;
    let DISP = [];

    init();

    async function init() {
      META = await window.bibleAPI.getMeta();    // { books:[], chapters:{ [book]: [{chapter,maxVerse}, ...] } }
      DISP = await window.bibleAPI.getDisplays(); // [{id,name,size,pos,isPrimary},...]

      // books
      for (const b of META.books) {
        const opt = document.createElement('option');
        opt.value = b; opt.textContent = b;
        $book.appendChild(opt);
      }
      // displays
      for (const d of DISP) {
        const opt = document.createElement('option');
        opt.value = d.id;
        opt.textContent = `${d.name} ${d.isPrimary ? '(주)' : ''} ${d.size} ${d.pos}`;
        if (d.isPrimary) opt.selected = true;
        $disp.appendChild(opt);
      }

      // wire
      $book.addEventListener('change', onBook);
      $sCh.addEventListener('change', onStartChapter);
      $eCh.addEventListener('change', onEndChapter);
      $sVs.addEventListener('change', syncIfSame);
      $same.addEventListener('change', onSameToggle);
      $btn.addEventListener('click', onShow);

      // default populate
      if (META.books.length) {
        $book.value = META.books[0];
        onBook();
      }
    }

    function onBook() {
      const b = $book.value;
      const chArr = META.chapters[b] || [];
      fillChSelect($sCh, chArr);
      fillChSelect($eCh, chArr);
      // default to chapter 1
      if (chArr.length) {
        $sCh.value = String(chArr[0].chapter);
        $eCh.value = String(chArr[0].chapter);
        onStartChapter();
        onEndChapter();
        syncIfSame();
      }
    }

    function fillChSelect(sel, chArr) {
      sel.innerHTML = '';
      for (const { chapter } of chArr) {
        const opt = document.createElement('option');
        opt.value = chapter;
        opt.textContent = chapter;
        sel.appendChild(opt);
      }
    }

    function fillVsSelect(sel, maxVerse) {
      sel.innerHTML = '';
      for (let i = 1; i <= maxVerse; i++) {
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i;
        sel.appendChild(opt);
      }
    }

    function getMaxVerse(b, ch) {
      const found = (META.chapters[b] || []).find(x => x.chapter === Number(ch));
      return found ? found.maxVerse : 1;
    }

    function onStartChapter() {
      const b = $book.value;
      const maxV = getMaxVerse(b, $sCh.value);
      fillVsSelect($sVs, maxV);
      $sVs.value = "1";
      // if same, mirror into end
      syncIfSame();
    }

    function onEndChapter() {
      const b = $book.value;
      const maxV = getMaxVerse(b, $eCh.value);
      fillVsSelect($eVs, maxV);
      $eVs.value = String(maxV);
    }

    function onSameToggle() {
      const same = $same.checked;
      $eCh.disabled = same;
      $eVs.disabled = same;
      syncIfSame();
    }

    function syncIfSame() {
      if (!$same.checked) return;
      $eCh.value = $sCh.value;
      // end verse clamps to available max in that chapter
      const maxEnd = getMaxVerse($book.value, $eCh.value);
      const sVal = Number($sVs.value);
      fillVsSelect($eVs, maxEnd);
      $eVs.value = String(Math.min(sVal, maxEnd));
    }

    async function onShow() {
      const payload = {
        book: $book.value,
        sCh: Number($sCh.value),
        sVs: Number($sVs.value),
        eCh: Number($eCh.value),
        eVs: Number($eVs.value),
        fontSize: Number($font.value) || 28,
        displayId: Number($disp.value) // Electron display.id is number
      };
      if ($same.checked) { payload.eCh = payload.sCh; payload.eVs = payload.sVs; }

      // sanity: ensure start ≤ end (main에서 한 번 더 normalize)
      await window.bibleAPI.openPassage(payload);
    }
  </script>
</body>
</html>
